'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.mergeLoaderConfig = mergeLoaderConfig;
exports.createStyleLoader = createStyleLoader;
exports.createLoaders = createLoaders;
exports.createExtraLoaders = createExtraLoaders;
exports.failBuildOnCompilationError = failBuildOnCompilationError;
exports.createPlugins = createPlugins;
exports.getTopLevelLoaderConfig = getTopLevelLoaderConfig;
exports['default'] = createWebpackConfig;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _extractTextWebpackPlugin = require('extract-text-webpack-plugin');

var _extractTextWebpackPlugin2 = _interopRequireDefault(_extractTextWebpackPlugin);

var _htmlWebpackPlugin = require('html-webpack-plugin');

var _htmlWebpackPlugin2 = _interopRequireDefault(_htmlWebpackPlugin);

var _npmInstallWebpackPlugin = require('npm-install-webpack-plugin');

var _npmInstallWebpackPlugin2 = _interopRequireDefault(_npmInstallWebpackPlugin);

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _webpackMerge = require('webpack-merge');

var _webpackMerge2 = _interopRequireDefault(_webpackMerge);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _utils = require('./utils');

// Top-level property names reserved for webpack config
// From http://webpack.github.io/docs/configuration.html
var WEBPACK_RESERVED = 'context entry output module resolve resolveLoader externals target bail profile cache watch watchOptions debug devtool devServer node amd loader recordsPath recordsInputPath recordsOutputPath plugins'.split(' ');

var combineLoaders = function combineLoaders(loaders) {
  return loaders.map(function (loader) {
    var query = _qs2['default'].stringify(loader.query, { arrayFormat: 'brackets' });
    return '' + loader.loader + (query && '?' + query);
  }).join('!');
};

exports.combineLoaders = combineLoaders;
/**
 * Merge webpack loader config ({test, loader, query, inclue, exclude}) objects.
 */

function mergeLoaderConfig() {
  var defaultConfig = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // Don't include a 'config' object if the user provided one - this will be
  // configured at the top level instead.
  var config = userConfig.config;

  var userLoaderConfig = _objectWithoutProperties(userConfig, ['config']);

  var loader = _webpackMerge2['default'](defaultConfig, buildConfig, userLoaderConfig);
  if (loader.query && Object.keys(loader.query).length === 0) {
    delete loader.query;
  }
  return loader;
}

/**
 * Create a function which configures a loader identified by a unique id, with
 * the option to override defaults with build-specific and user config.
 */
var loaderConfigFactory = function loaderConfigFactory(buildConfig, userConfig) {
  return function (id, defaultConfig) {
    if (id) {
      return _extends({ id: id }, mergeLoaderConfig(defaultConfig, buildConfig[id], userConfig[id]));
    }
    return defaultConfig;
  };
};

exports.loaderConfigFactory = loaderConfigFactory;
/**
 * Create a function which applies a prefix to a given name when a prefix is
 * given, unless the prefix ends with a name, in which case the prefix itself is
 * returned.
 * The latter rule is to allow loaders created for CSS preprocessor plugins to
 * be given unique ids for user configuration without duplicating the name of
 * the loader.
 * e.g.: styleLoaderName('sass')('css') => 'sass-css'
 *       styleLoaderName('sass')('sass') => 'sass' (as opposed to 'sass-sass')
 */
var styleLoaderName = function styleLoaderName(prefix) {
  return function (name) {
    if (prefix && _utils.endsWith(prefix, name)) {
      return prefix;
    }
    return prefix ? prefix + '-' + name : name;
  };
};

exports.styleLoaderName = styleLoaderName;
/**
 * Create a default style-handling pipeline for either a static build (default)
 * or a server build.
 */

function createStyleLoader(loader, server) {
  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref$prefix = _ref.prefix;
  var prefix = _ref$prefix === undefined ? null : _ref$prefix;
  var _ref$extraLoader = _ref.extraLoader;
  var extraLoader = _ref$extraLoader === undefined ? null : _ref$extraLoader;

  var name = styleLoaderName(prefix);
  var loaders = [loader(name('css'), {
    loader: require.resolve('css-loader')
  }), loader(name('autoprefixer'), {
    loader: require.resolve('autoprefixer-loader')
  })];

  if (extraLoader) {
    loaders.push(loader(name(extraLoader.id), extraLoader.config));
  }

  if (server) {
    loaders.unshift(loader(name('style'), {
      loader: require.resolve('style-loader')
    }));
    return combineLoaders(loaders);
  } else {
    return _extractTextWebpackPlugin2['default'].extract(combineLoaders(loaders));
  }
}

/**
 * Final webpack loader config consists of:
 * - the default set of loaders created in this function, with build and user
 *   config tweaks based on loader id.
 * - extra loaders defined in build config, with user config tweaks based
 *   on loader id.
 * - extra loaders created for CSS preprocessor plugins, with user config
 *   tweaks based on loader id.
 * - extra loaders defined in user config.
 */

function createLoaders(server) {
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  var pluginConfig = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var loader = loaderConfigFactory(buildConfig, userConfig);

  var loaders = [loader('babel', {
    test: /\.jsx?$/,
    loader: require.resolve('babel-loader'),
    exclude: /node_modules/
  }), loader('css-pipeline', {
    test: /\.css$/,
    loader: createStyleLoader(loader, server),
    exclude: /node_modules/
  }), loader('vendor-css-pipeline', {
    test: /\.css$/,
    loader: createStyleLoader(loader, server, {
      prefix: 'vendor'
    }),
    include: /node_modules/
  }), loader('graphics', {
    test: /\.(gif|png)$/,
    loader: require.resolve('url-loader'),
    query: {
      limit: 10240
    }
  }), loader('jpeg', {
    test: /\.jpe?g$/,
    loader: require.resolve('file-loader')
  }), loader('fonts', {
    test: /\.(otf|svg|ttf|woff|woff2)(\?v=\d+\.\d+\.\d+)?$/,
    loader: require.resolve('url-loader'),
    query: {
      limit: 10240
    }
  }), loader('eot', {
    test: /\.eot(\?v=\d+\.\d+\.\d+)?$/,
    loader: require.resolve('file-loader')
  }), loader('json', {
    test: /\.json$/,
    loader: require.resolve('json-loader')
  })].concat(createExtraLoaders(buildConfig.extra, userConfig), userConfig.extra || []);

  if (pluginConfig.cssPreprocessors) {
    Object.keys(pluginConfig.cssPreprocessors).forEach(function (id) {
      var _pluginConfig$cssPreprocessors$id = pluginConfig.cssPreprocessors[id];
      var test = _pluginConfig$cssPreprocessors$id.test;

      var config = _objectWithoutProperties(_pluginConfig$cssPreprocessors$id, ['test']);

      loaders.push(loader(id + '-pipeline', {
        test: test,
        loader: createStyleLoader(loader, server, {
          extraLoader: { id: id, config: config },
          prefix: id
        }),
        exclude: /node_modules/
      }));
      loaders.push(loader('vendor-' + id + '-pipeline', {
        test: test,
        loader: createStyleLoader(loader, server, {
          extraLoader: { id: id, config: config },
          prefix: 'vendor-' + id
        }),
        include: /node_modules/
      }));
    });
  }

  return loaders;
}

/**
 * Create loaders from loader definitions which may include an id attribute for
 * user customisation. It's assumed these are being created from build config.
 */

function createExtraLoaders() {
  var extraLoaders = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var userConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var loader = loaderConfigFactory({}, userConfig);
  return extraLoaders.map(function (extraLoader) {
    var id = extraLoader.id;

    var loaderConfig = _objectWithoutProperties(extraLoader, ['id']);

    return loader(id, loaderConfig);
  });
}

/**
 * A webpack plugin which forces the build to fail by exiting with a non-zero
 * code when there are compilation errors. This is intended for use on a CI
 * server which is running webpack builds.
 */

function failBuildOnCompilationError() {
  this.plugin('done', function (_ref2) {
    var compilation = _ref2.compilation;

    if (compilation.errors && compilation.errors.length > 0) {
      console.error(_chalk2['default'].red('nwb: webpack build failed:'));
      compilation.errors.forEach(function (error) {
        return console.error(_chalk2['default'].red(error.message));
      });
      process.exit(1);
    }
  });
}

/**
 * Final webpack plugin config consists of:
 * - the default set of plugins created by this function based on whether or not
 *   a server build is being configured, plus environment variables.
 * - extra plugins managed by this function, whose inclusion is triggered by
 *   build config, which provides default configuration for them which can be
 *   tweaked by user plugin config when appropriate.
 * - any extra plugins defined in build and user config.
 */

function createPlugins(server) {
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  var
  // Banner comment to be added to each generated file in a UMD build
  banner = buildConfig.banner;
  var
  // Extra constant replacements for DefinePlugin
  define = buildConfig.define;
  var
  // Escape hatch for adding new build-specific plugins
  extra = buildConfig.extra;
  var
  // Options for HtmlWebpackPlugin
  html = buildConfig.html;
  var
  // Options for NpmInstallPlugin
  install = buildConfig.install;
  var
  // Name to use for a vendor chunk - providing a name causes it to be created.
  vendorChunkName = buildConfig.vendorChunkName;

  var plugins = [new _webpack2['default'].DefinePlugin(_extends({
    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development')
  }, define, userConfig.define)), new _webpack.optimize.DedupePlugin(), new _webpack.optimize.OccurenceOrderPlugin()];

  // Assumption: we're always hot reloading if we're bundling on the server
  if (server) {
    plugins.unshift(new _webpack2['default'].HotModuleReplacementPlugin(), new _webpack2['default'].NoErrorsPlugin());
  }

  if (process.env.CONTINUOUS_INTEGRATION === 'true') {
    plugins.unshift(failBuildOnCompilationError);
  }

  if (!server) {
    plugins.push(new _extractTextWebpackPlugin2['default']('[name].css'));

    // Move modules imported from node_modules into a vendor chunk
    if (vendorChunkName) {
      plugins.push(new _webpack.optimize.CommonsChunkPlugin({
        name: vendorChunkName,
        minChunks: function minChunks(module, count) {
          return module.resource && module.resource.indexOf(_path2['default'].resolve('node_modules')) === 0;
        }
      }));
    }
  }

  if (process.env.NODE_ENV === 'production') {
    plugins.push(new _webpack.optimize.UglifyJsPlugin({
      compress: {
        screw_ie8: true,
        warnings: false
      }
    }));
  }

  if (html) {
    plugins.push(new _htmlWebpackPlugin2['default'](_extends({
      template: _path2['default'].join(__dirname, '../templates/webpack-template.html')
    }, html)));
  }

  if (install) {
    plugins.push(new _npmInstallWebpackPlugin2['default'](_extends({}, install, userConfig.install)));
  }

  if (banner) {
    plugins.push(new _webpack2['default'].BannerPlugin(banner));
  }

  if (extra) {
    plugins = plugins.concat(extra);
  }

  return plugins;
}

/**
 * Extract top-level loader configuration provided by the user.
 */

function getTopLevelLoaderConfig(userLoaderConfig) {
  var cssPreprocessors = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (!userLoaderConfig || Object.keys(userLoaderConfig).length === 0) {
    return {};
  }

  var topLevelLoaderConfig = {};
  Object.keys(userLoaderConfig).forEach(function (loaderId) {
    var loaderConfig = userLoaderConfig[loaderId];
    if (!('config' in loaderConfig)) return;

    // Determine the proeprty to set top level loader config under
    var configPropertyName = undefined;

    // Trust the user to specify their own config key for loaders with support
    if (loaderConfig.query && 'config' in loaderConfig.query) {
      configPropertyName = loaderConfig.query.config;
    } else {
      // Otherwise, determine the correct config key
      var id = loaderId.replace(/^vendor-/, '');
      if (id in cssPreprocessors) {
        if (!cssPreprocessors[id].defaultConfig) {
          throw new Error('The ' + id + ' CSS preprocessor loader doesn\'t support a default top-level config object.');
        }
        configPropertyName = cssPreprocessors[id].defaultConfig;
      } else if (id === 'babel') {
        configPropertyName = 'babel';
      } else {
        throw new Error('The ' + id + ' loader doesn\'t appear to support a default top-level config object.');
      }
    }

    if (WEBPACK_RESERVED.indexOf(configPropertyName) !== -1) {
      throw new Error('User config for the ' + loaderId + ' loader cannot be set in ' + configPropertyName + ' - this is reserved for use by Webpack.');
    } else if (configPropertyName in topLevelLoaderConfig) {
      throw new Error('User config for the ' + loaderId + ' loader cannot be set in ' + configPropertyName + ' - this has already been used.');
    }

    topLevelLoaderConfig[configPropertyName] = loaderConfig.config;
  });

  return topLevelLoaderConfig;
}

/**
 * Create a webpack config with a curated set of default loaders suitable for
 * creating a static build (default) or serving an app with hot reloading.
 */

function createWebpackConfig(buildConfig) {
  var nwbPluginConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  _assert2['default'].equal(_utils.typeOf(buildConfig), 'object', 'buildConfig is required');
  _debug2['default']('createWebpackConfig buildConfig = %j', buildConfig);

  // Final webpack config is primarily driven by build configuration for the nwb
  // command being run. Each command configures a default, working webpack
  // configuration for the task it needs to perform.
  var _buildConfig$loaders = buildConfig.loaders;
  var
  // These build config items are used to creating chunks of webpack config,
  // rather than being included as-is.
  loaders = _buildConfig$loaders === undefined ? {} : _buildConfig$loaders;
  var _buildConfig$plugins = buildConfig.plugins;
  var plugins = _buildConfig$plugins === undefined ? {} : _buildConfig$plugins;
  var _buildConfig$resolve = buildConfig.resolve;
  var resolve = _buildConfig$resolve === undefined ? {} : _buildConfig$resolve;
  var _buildConfig$server = buildConfig.server;
  var server = _buildConfig$server === undefined ? false : _buildConfig$server;

  var otherBuildConfig = _objectWithoutProperties(buildConfig, ['loaders', 'plugins', 'resolve', 'server']);

  var _userConfig$loaders = userConfig.loaders;
  var userLoaderConfig = _userConfig$loaders === undefined ? {} : _userConfig$loaders;
  var _userConfig$plugins = userConfig.plugins;
  var userPluginConfig = _userConfig$plugins === undefined ? {} : _userConfig$plugins;
  var _userConfig$extra = userConfig.extra;
  var userExtraWebpackConfig = _userConfig$extra === undefined ? {} : _userConfig$extra;

  return _webpackMerge2['default'](_extends({
    module: {
      loaders: createLoaders(server, loaders, userLoaderConfig, nwbPluginConfig)
    },
    plugins: createPlugins(server, plugins, userPluginConfig),
    resolve: _webpackMerge2['default']({
      extensions: ['', '.web.js', '.js', '.jsx', '.json'],
      // Fall back to resolving runtime dependencies from nwb's dependencies,
      // e.g. for babel-runtime when using Babel stage: 0 and optional:
      // ['runtime'] for async/await.
      fallback: _path2['default'].join(__dirname, '../node_modules')
    }, resolve)
  }, otherBuildConfig, getTopLevelLoaderConfig(userLoaderConfig, nwbPluginConfig.cssPreprocessors)), userExtraWebpackConfig);
}

// Extra loaders from build config, still configurable via user config when
// the loaders specify an id.

// TODO Remove in nwb 0.9
// Extra loaders from user config

// Any other build config provided is merged directly into the final webpack
// config to provide the rest of the default config.

// Loader and plugin config is managed by nwb, with the ability to use
// "extra" config to define arbitrary additional loaders and plugins.

// Any extra user webpack config is deep-merged into the generated config
// object to give the user even more control. This needs to be used very
// carefully as different nwb commands have different webpack config needs.

// Top level loader config can be supplied via user "loaders" config, so we
// detect, extract and where possible validate it before merging it into the
// final webpack config object.